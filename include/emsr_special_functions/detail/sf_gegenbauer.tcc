
// Copyright (C) 2016-2019 Free Software Foundation, Inc.
// Copyright (C) 2020-2022 Edward M. Smith-Rowland
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or (at
// your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/sf_gegenbauer.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{cmath}
 */

#ifndef SF_GEGENBAUER_TCC
#define SF_GEGENBAUER_TCC 1

#include <stdexcept>

#include <emsr/specfun_state.h>
#include <emsr/numeric_limits.h>
#include <emsr/sf_gamma.h> // factorial

namespace emsr
{
namespace detail
{
  /**
   * Return the Gegenbauer polynomial @f$ C_n^{(\lambda)}(x) @f$ of degree @c n
   * and real order @f$ \lambda @f$ and argument @c x.
   *
   * The Gegenbauer polynomials are generated by a three-term recursion relation:
   * @f[
   *    C_n^{(\lambda)}(x)
   *     = \frac{1}{n}\left[ 2x(n+\lambda-1)C_{n-1}^{(\lambda)}(x)
   *     - (n + 2\lambda-2)C_{n-2}^{(\lambda)}(x) \right]
   * @f]
   * and @f$ C_0^{(\lambda)}(x) = 1 @f$, @f$ C_1^{(\lambda)}(x) = 2\lambda x @f$.
   * This works for @f$ \lambda > -1/2 @f$
   *
   * @tparam  Tp  The real type of the argument and order
   * @param  n  The non-negative integral degree
   * @param  lambda  The order of the Gegenbauer polynomial
   * @param  x  The real argument
   */
  template<typename Tp>
    emsr::gegenbauer_t<Tp>
    gegenbauer_recur(unsigned int n, Tp lambda, Tp x)
    {
      const auto s_NaN = emsr::quiet_NaN(x);

      if (std::isnan(lambda) || std::isnan(x))
	return {n, lambda, x, s_NaN, s_NaN, s_NaN};

      auto C_nm2 = Tp{1};
      if (n == 0)
	return {n, lambda, x, C_nm2, Tp{0}, Tp{0}};

      auto C_nm1 = Tp{2} * lambda * x;
      if (n == 1)
	return {n, lambda, x, C_nm1, C_nm2, Tp{0}};

      auto C_n = (Tp{2} * (Tp{1} + lambda) * x * C_nm1
		 - Tp{2} * lambda * C_nm2) / Tp(2);
      for (unsigned int k = 3; k <= n; ++k)
	{
	  C_nm2 = C_nm1;
	  C_nm1 = C_n;
	  C_n = (Tp{2} * (Tp(k) - Tp{1} + lambda) * x * C_nm1
		- (Tp(k) - Tp{2} + Tp{2} * lambda) * C_nm2)
	      / Tp(k);
	}
      return {n, lambda, x, C_n, C_nm1, C_nm2};
    }

  /**
   * Return a vector containing the zeros of the Gegenbauer or ultraspherical
   * polynomial @f$ C_n^{(\lambda)}@f$.
   * This works for @f$ \lambda > -1/2 @f$
   *
   * @tparam  Tp  The real type of the order
   * @param[in]  n  The degree of the Gegenbauer polynomial
   * @param[in]  lambda  The order of the Gegenbauer polynomial
   */
  template<typename Tp>
    std::vector<emsr::QuadraturePoint<Tp>>
    gegenbauer_zeros(unsigned int n, Tp lambda)
    {
      const auto s_eps = emsr::epsilon(lambda);
      const unsigned int s_maxit = 1000u;
      std::vector<emsr::QuadraturePoint<Tp>> pt(n);

      Tp z;
      Tp w;
      for (auto i = 1u; i <= n; ++i)
	{
	  if (i == 1)
	    {
	      auto an = lambda / n;
	      auto an2 = an * an;
	      auto r1 = (1.0 + lambda) * (2.78 / (4.0 + n * n)
			+ 0.768 * an / n);
	      auto r2 = 1.0 + 1.48 * an + 0.96 * an + 1.282 * an2;
	      z = 1.0 - r1 / r2;
	    }
	  else if (i == 2)
	    {
	      auto r1 = (4.1 + lambda)
			/ ((1.0 + lambda) * (1.0 + 0.156 * lambda));
	      auto r2 = 1.0
			+ 0.06 * (n - 8.0) * (1.0 + 0.12 * lambda) / n;
	      auto r3 = 1.0
		   + 0.012 * lambda * (1.0 + 0.25 * std::abs(lambda)) / n;
	      z -= (1.0 - z) * r1 * r2 * r3;
	    }
	  else if (i == 3)
	    {
	      auto r1 = (1.67 + 0.28 * lambda) / (1.0 + 0.37 * lambda);
	      auto r2 = 1.0 + 0.22 * (n - 8.0) / n;
	      auto r3 = 1.0 + 8.0 *lambda / ((6.28 + lambda) * n * n);
	      z -= (pt[0].point - z) * r1 * r2 * r3;
	    }
	  else if (i == n - 1)
	    {
	      auto r1 = (1.0 + 0.235 * lambda) / (0.766 + 0.119 * lambda);
	      auto r2 = 1.0 / (1.0 + 0.639 * (n - 4.0)
						/ (1.0 + 0.71 * (n - 4.0)));
	      auto r3 = 1.0 / (1.0 + 20.0 * lambda
				/ ((7.5 + lambda) * n * n));
	      z += (z - pt[n - 4].point) * r1 * r2 * r3;
	    }
	  else if (i == n)
	    {
	      auto r1 = (1.0 + 0.37 * lambda) / (1.67 + 0.28 * lambda);
	      auto r2 = 1.0 / (1.0 + 0.22 * (n - 8.0) / n);
	      auto r3 = 1.0 / (1.0 + 8.0 * lambda
				 / ((6.28 + lambda) * n * n));
	      z += (z - pt[n - 3].point) * r1 * r2 * r3;
	    }
	  else
	    z = 3.0 * pt[i - 2].point
		- 3.0 * pt[i - 3].point + pt[i - 4].point;

	  auto __2lambda = Tp{2} * lambda;
	  for (auto its = 1u; its <= s_maxit; ++its)
	    {
	      auto temp = Tp{2} + __2lambda;
	      auto C1 = (temp * z) / Tp{2};
	      auto C2 = Tp{1};
	      for (auto j = 2u; j <= n; ++j)
		{
		  auto C3 = C2;
		  C2 = C1;
		  temp = Tp(2 * j) + __2lambda;
		  auto a = Tp(2 * j) * (j + __2lambda)
			   * (temp - Tp{2});
		  auto b = (temp - Tp{1})
			   * temp * (temp - Tp{2}) * z;
		  auto c = Tp{2} * (j - 1 + lambda)
			   * (j - 1 + lambda) * temp;
		  C1 = (b * C2 - c * C3) / a;
		}
	      auto Cp = (n * (-temp * z) * C1
			+ Tp{2} * (n + lambda) * (n + lambda) * C2)
			/ (temp * (Tp{1} - z * z));
	      auto z1 = z;
	      z = z1 - C1 / Cp;
	      if (std::abs(z - z1) <= s_eps)
		{
		  w = std::exp(std::lgamma(lambda + Tp(n))
			       + std::lgamma(lambda + Tp(n))
			       - std::lgamma(Tp(n + 1))
			       - std::lgamma(Tp(n + 1) + __2lambda))
		      * temp * std::pow(Tp{2}, __2lambda) / (Cp * C2);
		  break;
		}
	      if (its > s_maxit)
		throw std::logic_error("gegenbauer_zeros: Too many iterations");
	    }
	  pt[i - 1].point = z;
	  pt[i - 1].weight = w;
	}

      return pt;
    }

} // namespace detail
} // namespace emsr

#endif // SF_GEGENBAUER_TCC
